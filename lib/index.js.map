{"version":3,"sources":["../src/index.js"],"names":["ENDPOINT_URL","APPLE_KEYS_CACHE","getAuthorizationUrl","options","clientID","Error","redirectUri","url","URL","pathname","searchParams","append","state","scope","includes","responseMode","response_mode","toString","getClientSecret","teamId","keyIdentifier","privateKeyPath","privateKey","fs","existsSync","timeNow","Math","floor","Date","now","claims","iss","iat","exp","expAfter","aud","sub","header","alg","kid","key","readFileSync","jwt","sign","algorithm","getAuthorizationToken","code","clientSecret","form","client_id","client_secret","grant_type","redirect_uri","method","body","JSON","stringify","then","res","json","refreshAuthorizationToken","refreshToken","refresh_token","_getApplePublicKeys","disableCaching","data","keyValues","keys","map","publKeyObj","NodeRSA","importKey","n","Buffer","from","e","publicKey","exportKey","_getIdTokenApplePublicKey","cb","verifyIdToken","idToken","Promise","resolve","reject","verify","algorithms","issuer","error","decoded"],"mappings":"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","sourcesContent":["/* @flow */\nimport { URL } from 'url';\nimport fs from 'fs';\nimport jwt from 'jsonwebtoken';\nimport NodeRSA from 'node-rsa';\nimport fetch from 'node-fetch';\n\nexport type AppleIdTokenType = {\n  /** The issuer-registered claim key, which has the value https://appleid.apple.com. */\n  iss: string,\n  /** The unique identifier for the user. */\n  sub: string,\n  /** Your client_id in your Apple Developer account. */\n  aud: string,\n  /** The expiry time for the token. This value is typically set to five minutes. */\n  exp: string,\n  /** The time the token was issued. */\n  iat: string,\n  /** A String value used to associate a client session and an ID token. This value is used to mitigate replay attacks and is present only if passed during the authorization request. */\n  nonce: string,\n  /** A Boolean value that indicates whether the transaction is on a nonce-supported platform. If you sent a nonce in the authorization request but do not see the nonce claim in the ID token, check this claim to determine how to proceed. If this claim returns true you should treat nonce as mandatory and fail the transaction; otherwise, you can proceed treating the nonce as optional. */\n  nonce_supported: boolean,\n  /** The user's email address. */\n  email: string,\n  /** A Boolean value that indicates whether the service has verified the email. The value of this claim is always true because the servers only return verified email addresses. */\n  email_verified: boolean,\n};\n\nexport type AppleAuthorizationTokenResponseType = {\n  /** A token used to access allowed data. */\n  access_token: string,\n  /** It will always be Bearer. */\n  token_type: 'Bearer',\n  /** The amount of time, in seconds, before the access token expires. */\n  expires_in: 300,\n  /** used to regenerate (new) access tokens. */\n  refresh_token: string,\n  /** A JSON Web Token that contains the userâ€™s identity information. */\n  id_token: string,\n};\n\nconst ENDPOINT_URL = 'https://appleid.apple.com';\n\n/** Apple keys cache - { kid: public_key } */\nlet APPLE_KEYS_CACHE: { [kid: string]: string } = {};\n\n/** Gets the Apple Authorizaion URL */\nconst getAuthorizationUrl = (\n  options: {\n    clientID: string,\n    redirectUri: string,\n    responseMode?: 'query' | 'fragment' | 'form_post',\n    state?: string,\n    scope?: string,\n  } = {},\n): string => {\n  // Handle input errors\n  if (!options.clientID) {\n    throw Error('clientID is empty');\n  }\n  if (!options.redirectUri) {\n    throw Error('redirectUri is empty');\n  }\n\n  const url = new URL(ENDPOINT_URL);\n  url.pathname = '/auth/authorize';\n\n  url.searchParams.append('response_type', 'code');\n  url.searchParams.append('state', options.state || 'state');\n  url.searchParams.append('client_id', options.clientID);\n  url.searchParams.append('redirect_uri', options.redirectUri);\n  url.searchParams.append('scope', `openid${` ${options.scope}`}`);\n\n  if (options.scope?.includes('email')) {\n    // Force set response_mode to 'form_post' if scope includes email\n    url.searchParams.append('response_mode', 'form_post');\n  } else if (options.responseMode) {\n    // Set response_mode to input responseMode\n    url.searchParams.append('response_mode', options.response_mode);\n  }\n\n  return url.toString();\n};\n\n/** Gets your Apple clientSecret */\nconst getClientSecret = (\n  options: {\n    clientID: string,\n    teamId: string,\n    keyIdentifier: string,\n    privateKey?: string, // one of [privateKeyPath, privateKey] need to be passed\n    privateKeyPath?: string, // one of [privateKeyPath, privateKey] need to be passed\n    expAfter?: number,\n  } = {},\n): string => {\n  // Handle input errors\n  if (!options.clientID) {\n    throw new Error('clientID is empty');\n  }\n  if (!options.teamId) {\n    throw new Error('teamId is empty');\n  }\n  if (!options.keyIdentifier) {\n    throw new Error('keyIdentifier is empty');\n  }\n  if (!options.privateKeyPath && !options.privateKey) {\n    throw new Error('privateKey and privateKeyPath are empty');\n  }\n  if (options.privateKeyPath && options.privateKey) {\n    throw new Error(\n      'privateKey and privateKeyPath cannot be passed together, choose one of them',\n    );\n  }\n  if (options.privateKeyPath && !fs.existsSync(options.privateKeyPath)) {\n    throw new Error(\"Can't find private key\");\n  }\n\n  const timeNow = Math.floor(Date.now() / 1000);\n\n  const claims = {\n    iss: options.teamId,\n    iat: timeNow,\n    exp: timeNow + (options.expAfter || 300), // default to 5 minutes\n    aud: ENDPOINT_URL,\n    sub: options.clientID,\n  };\n\n  const header = { alg: 'ES256', kid: options.keyIdentifier };\n  const key = options.privateKeyPath\n    ? fs.readFileSync(options.privateKeyPath)\n    : options.privateKey;\n\n  return jwt.sign(claims, key, { algorithm: 'ES256', header });\n};\n\n/** Gets an Apple authorization token */\nconst getAuthorizationToken = async (\n  code: string,\n  options: {\n    clientID: string,\n    redirectUri: string,\n    clientSecret: string,\n  },\n): Promise<AppleAuthorizationTokenResponseType> => {\n  // Handle input errors\n  if (!options.clientID) {\n    throw new Error('clientID is empty');\n  }\n  if (!options.clientSecret) {\n    throw new Error('clientSecret is empty');\n  }\n\n  const url = new URL(ENDPOINT_URL);\n  url.pathname = '/auth/token';\n\n  const form = {\n    client_id: options.clientID,\n    client_secret: options.clientSecret,\n    code,\n    grant_type: 'authorization_code',\n    redirect_uri: options.redirectUri,\n  };\n\n  if (options.redirectUri) {\n    form.redirect_uri = options.redirectUri;\n  }\n\n  return fetch(url.toString(), {\n    method: 'POST',\n    body: JSON.stringify(form),\n  }).then((res) => res.json());\n};\n\n/** Refreshes an Apple authorization token */\nconst refreshAuthorizationToken = async (\n  refreshToken: string,\n  options: {\n    clientID: string,\n    clientSecret: string,\n  },\n): Promise<AppleAuthorizationTokenResponseType> => {\n  if (!options.clientID) {\n    throw new Error('clientID is empty');\n  }\n  if (!options.clientSecret) {\n    throw new Error('clientSecret is empty');\n  }\n\n  const url = new URL(ENDPOINT_URL);\n  url.pathname = '/auth/token';\n\n  const form = {\n    client_id: options.clientID,\n    client_secret: options.clientSecret,\n    refresh_token: refreshToken,\n    grant_type: 'refresh_token',\n  };\n\n  return fetch(url.toString(), {\n    method: 'POST',\n    body: JSON.stringify(form),\n  }).then((res) => res.json());\n};\n\n/** Gets an Array of Apple Public Keys that can be used to decode Apple's id tokens */\nconst _getApplePublicKeys = async ({\n  disableCaching,\n}: { disableCaching?: boolean } = {}): Array<string> => {\n  const url = new URL(ENDPOINT_URL);\n  url.pathname = '/auth/keys';\n\n  // Fetch Apple's Public keys\n  const data = await fetch(url.toString(), {\n    method: 'GET',\n  }).then((res) => res.json());\n\n  // Reset cache - will be refilled below\n  APPLE_KEYS_CACHE = {};\n\n  // Parse and cache keys\n  const keyValues = data.keys.map((key) => {\n    // parse key\n    const publKeyObj = new NodeRSA();\n    publKeyObj.importKey(\n      { n: Buffer.from(key.n, 'base64'), e: Buffer.from(key.e, 'base64') },\n      'components-public',\n    );\n    const publicKey = publKeyObj.exportKey(['public']);\n\n    // cache key\n    if (!disableCaching) {\n      APPLE_KEYS_CACHE[key.kid] = publicKey;\n    }\n\n    // return public key string\n    return publicKey;\n  });\n\n  // Return parsed keys\n  return keyValues;\n};\n\n/** Gets the Apple Public Key corresponding to the JSON's header  */\nconst _getIdTokenApplePublicKey = async (\n  header: string,\n  cb: (?Error, ?string) => any,\n): Function => {\n  // attempt fetching from cache\n  if (APPLE_KEYS_CACHE[header.kid]) {\n    return cb(null, APPLE_KEYS_CACHE[header.kid]);\n  }\n  // fetch and cache current Apple public keys\n  await _getApplePublicKeys();\n  // attempt fetching from cache\n  if (APPLE_KEYS_CACHE[header.kid]) {\n    return cb(null, APPLE_KEYS_CACHE[header.kid]);\n  }\n  // key was not fetched - highly unlikely, means apple is having issues or somebody faked the JSON\n  return cb(new Error('input error: Invalid id token public key id'));\n};\n\n/** Verifies an Apple id token */\nconst verifyIdToken = async (\n  /** id_token provided by Apple post Auth  */\n  idToken: string,\n  /** JWT verify options - Full list here https://github.com/auth0/node-jsonwebtoken#jwtverifytoken-secretorpublickey-options-callback  */\n  options: Object = {},\n): Promise<AppleIdTokenType> =>\n  new Promise((resolve, reject) =>\n    jwt.verify(\n      idToken,\n      _getIdTokenApplePublicKey,\n      {\n        algorithms: 'RS256',\n        issuer: ENDPOINT_URL,\n        ...options,\n      },\n      (error: Error, decoded: AppleIdTokenType) =>\n        error ? reject(error) : resolve(decoded),\n    ),\n  );\n\nexport {\n  getAuthorizationUrl,\n  getClientSecret,\n  getAuthorizationToken,\n  refreshAuthorizationToken,\n  verifyIdToken,\n  // Internals - exposed for hacky people\n  _getApplePublicKeys,\n};\n\n/* For backwards compatibility with es5 */\nexport default {\n  getAuthorizationUrl,\n  getClientSecret,\n  getAuthorizationToken,\n  refreshAuthorizationToken,\n  verifyIdToken,\n  // Internals - exposed for hacky people\n  _getApplePublicKeys,\n};\n"],"file":"index.js"}